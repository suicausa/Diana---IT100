/*
 * File: Breakout.java
 * -------------------
 * Name: Diana
 * 
 * This file will eventually implement the game of Breakout.
 * Reference: http://snipplr.com/view/62343/
 */

import acm.graphics.*;
import acm.program.*;
import acm.util.*;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

public class Breakout extends GraphicsProgram {

/** Width and height of application window in pixels */
	public static final int APPLICATION_WIDTH = 400;
	public static final int APPLICATION_HEIGHT = 600;

/** Dimensions of game board (usually the same) */
	private static final int WIDTH = APPLICATION_WIDTH;
	private static final int HEIGHT = APPLICATION_HEIGHT;

/** Dimensions of the paddle */
	private static final int PADDLE_WIDTH = 60;
	private static final int PADDLE_HEIGHT = 10;

/** Offset of the paddle up from the bottom */
	private static final int PADDLE_Y_OFFSET = 30;

/** Number of bricks per row */
	private static final int NBRICKS_PER_ROW = 10;

/** Number of rows of bricks */
	private static final int NBRICK_ROWS = 10;

/** Separation between bricks */
	private static final int BRICK_SEP = 4;

/** Width of a brick */
	private static final int BRICK_WIDTH =
	  (WIDTH - (NBRICKS_PER_ROW - 1) * BRICK_SEP) / NBRICKS_PER_ROW;

/** Height of a brick */
	private static final int BRICK_HEIGHT = 8;

/** Radius of the ball in pixels */
	private static final int BALL_RADIUS = 10;

/** Offset of the top brick row from the top */
	private static final int BRICK_Y_OFFSET = 70;

/** Number of turns */
	private static final int NTURNS = 3;

/** Animation delay or pause time between ball moves */ 
	private static final int DELAY = 50;
	
	

/* Method: run() */
/** Runs the Breakout program. */
	public void run() { 
 		numberOfTurns = NTURNS;
 		while(numberOfTurns > 0) {
 		setup();
 		play();
 		removeAll();
 		numberOfTurns --;
 		}
 		GLabel gameOver = new GLabel("GAME OVER");
 		gameOver.setLocation((WIDTH - gameOver.getWidth()) / 2, HEIGHT / 2);
 		remove(youLose);
 		remove(youWin);
 		add(gameOver);
 }
 	
 	private void setup() {
 		addMouseListeners();
 		createBricks();
 		createPaddle();
 	}
 	
 	private void createBricks() {
 		double xColumnOne = (WIDTH - ((NBRICKS_PER_ROW - 1) * BRICK_SEP + (NBRICKS_PER_ROW * BRICK_WIDTH)));
 		double yRow = BRICK_Y_OFFSET;
 		for (int i = 0; i < NBRICK_ROWS; i++) {		
 			for (int j = 0; j < NBRICKS_PER_ROW; j++) {
 	 			GRect brick = new GRect (xColumnOne, yRow, BRICK_WIDTH, BRICK_HEIGHT);
 	 			/* Sets row colors to the following standards:  "The color of the bricks remain constant for two rows and run in the following 
 	rainbow-like sequence: RED, ORANGE, YELLOW, GREEN, CYAN" */
 	 			if (i == 0 || i == 1) {	
 	 				brick.setColor(Color.RED);
 	 			} else if (i == 2 || i == 3) {
 	 				brick.setColor(Color.ORANGE);
 	 			} else if (i == 4 || i == 5) {
 	 				brick.setColor(Color.YELLOW);
 	 			} else if (i == 6 || i == 7) {
 	 				brick.setColor(Color.GREEN);
 	 			} else if (i == 8 || i == 9) {
 	 				brick.setColor(Color.CYAN);
 	 			}
 	 			brick.setFilled(true); 
 				add(brick);
 				xColumnOne += (BRICK_WIDTH + BRICK_SEP);
 			}
 			xColumnOne = (WIDTH - ((NBRICKS_PER_ROW - 1) * BRICK_SEP + (NBRICKS_PER_ROW * BRICK_WIDTH)));
 			yRow += (BRICK_HEIGHT + BRICK_SEP);
 		}
 	}
 	/* Creates paddle and sets starting location to center of canvas. */
 	private void createPaddle() {
 		paddle = new GRect ((WIDTH - PADDLE_WIDTH)/2, HEIGHT - PADDLE_Y_OFFSET, PADDLE_WIDTH, PADDLE_HEIGHT);
 		paddle.setFilled(true);
 		add(paddle);
 	}
 	/* Sets paddle to move with mouse cursor, stopping before it exits the canvas. */
 	public void mouseMoved(MouseEvent e) {
 		double paddleX = e.getX();
 		double paddleY = HEIGHT - PADDLE_Y_OFFSET;
 		paddle.setLocation(paddleX, paddleY);
 		if ((paddleX + PADDLE_WIDTH) > WIDTH) {
 			paddle.setLocation((WIDTH - PADDLE_WIDTH), paddleY);
 		}
 	}
 	
 	private void play() {
 		createBall();
 		waitForClick();
 		/* Y-velocity of ball */
 		vy = 5.0;
 		/* X-velocity of ball */
 		vx = rgen.nextDouble(1.0, 5.0); 
 		if (rgen.nextBoolean(0.5)) vx = -vx;
 		int bricksRemaining = (NBRICK_ROWS * NBRICKS_PER_ROW);
 		youWin = new GLabel("You Win!");
 		youWin.setLocation((WIDTH - youWin.getWidth()) / 2, HEIGHT / 2);
 		youLose = new GLabel("You Lose :(");
 		youLose.setLocation((WIDTH - youLose.getWidth()) / 2, HEIGHT / 2);
 		while (true) {
 			moveBall();
 			checkForWallCollision();
 			GObject collider = getCollidingObject();
 			/*Increases velocity in both directions by 0.15 each time the ball collides with the paddle. */
 			if (collider != null && collider == paddle) {
 				vy = vy + 0.15;
 				vx = vx + 0.15;
 				/* If the ball hits the first fifth of the paddle while traveling in a positive x-direction, 
 				 * or the last fifth of the paddle while traveling in a negative x-direction, x-velocity is doubled. 
 				 * If the inverse of either of these is true, the ball will bounce in the opposite x-direction as it was received,
 				 * and x-velocity is halved.
 				 */
 				if (vx > 0 && ball.getX() < (paddle.getX() + (PADDLE_WIDTH * 0.2))) {
 					vx = 0.5 * vx;
 					vx = -vx;
 					vy = -vy;
 				} else if (vx < 0 && ball.getX() < (paddle.getX() + (PADDLE_WIDTH * 0.2))) {
 					vx = 2 * vx;
 					vy = -vy;
 				} else if (vx < 0 && ball.getX() > (paddle.getX() + (PADDLE_WIDTH * 0.8))) {
 					vx = 0.5 * vx;
 					vx = -vx;
 					vy = -vy; 					
 				} else if (vx > 0 && ball.getX() > (paddle.getX() + (PADDLE_WIDTH * 0.8))) {
 					vx = 2 * vx;
 					vy = -vy;
 				} else vy = -vy;
 			}
 			if (collider != null && collider != paddle) {
 				remove(collider);
 				vy = -vy;
 				bricksRemaining --;
 			}
 			if (ball.getY() + 2 * BALL_RADIUS > HEIGHT) {
 				add(youLose);
 				remove(ball);
 				break;
 			}
 			if (bricksRemaining == 0) {
 				add(youWin);
 				remove(ball);
 				break;
 			}
 			pause(DELAY);
 		}
 		waitForClick();
 		remove(youLose);
 		remove(youWin);
 	}
 	
 	private void createBall(){
 		ball = new GOval ((WIDTH - (2 * BALL_RADIUS)) / 2, (HEIGHT - (2 * BALL_RADIUS)) / 2, 2 * BALL_RADIUS, 2 * BALL_RADIUS);
 		ball.setFilled(true);
 		add(ball);
 	}
 	
 	private void moveBall() {
 		ball.move(vx,vy);
 	}
 	
 	private void checkForWallCollision() {
 		if (ball.getX() + 2 * BALL_RADIUS > WIDTH || ball.getX() < 0) {
 			vx = -vx;
 		}
 		if (ball.getY() < 0) {
 			vy = -vy;
 		}
 	}
 	
 	/* Checks for ball collisions with objects other than the walls, using the four points of the surrounding rectangle as "check" points. */
 	private GObject getCollidingObject() {
 		if (getElementAt(ball.getX(), ball.getY()) != null) {
 			collidingObject = getElementAt(ball.getX(), ball.getY());
 		} else if (getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY()) != null) {
 			collidingObject = getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY());
 		} else if (getElementAt(ball.getX(), ball.getY() + (2 * BALL_RADIUS)) != null) {
 			collidingObject = getElementAt(ball.getX(), ball.getY() + (2 * BALL_RADIUS));
 		} else if (getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY() + (2 * BALL_RADIUS)) != null) {
 			collidingObject = getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY() + (2 * BALL_RADIUS));
 		} else {
 			collidingObject = null;
 		}
 		
 		return collidingObject;

 	}
 	
 	private GLabel youWin;
 	
 	private GLabel youLose;
 	
 	private int numberOfTurns;
 	
 	private GObject collidingObject;
 	
 	private GRect paddle;
 	
 	private GOval ball;
 	
 	private double vx, vy;
 	
 	private RandomGenerator rgen = RandomGenerator.getInstance();

}