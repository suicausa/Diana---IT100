/*
 * File: Breakout.java
 * -------------------
 * Name: Diana
 * 
 * This file will eventually implement the game of Breakout.
 * Reference: http://snipplr.com/view/62343/
 */

import acm.graphics.*;
import acm.program.*;
import acm.util.*;

import java.applet.*;
import java.awt.*;
import java.awt.event.*;

public void run() { 
		numberOfTurns = NTURNS;
		while(numberOfTurns > 0) {
		setup();
		play();
		removeAll();
		numberOfTurns --;
		}
		GLabel gameOver = new GLabel("GAME OVER");
		gameOver.setLocation((WIDTH - gameOver.getWidth()) / 2, HEIGHT / 2);
		remove(youLose);
		remove(youWin);
		add(gameOver);
}
	
	private void setup() {
		addMouseListeners();
		createBricks();
		createPaddle();
	}
	
	private void createBricks() {
		double xColumnOne = (WIDTH - ((NBRICKS_PER_ROW - 1) * BRICK_SEP + (NBRICKS_PER_ROW * BRICK_WIDTH)));
		double yRow = BRICK_Y_OFFSET;
		for (int i = 0; i < NBRICK_ROWS; i++) {		
			for (int j = 0; j < NBRICKS_PER_ROW; j++) {
	 			GRect brick = new GRect (xColumnOne, yRow, BRICK_WIDTH, BRICK_HEIGHT);
	 			/* Sets row colors to the following standards:  "The color of the bricks remain constant for two rows and run in the following 
	rainbow-like sequence: RED, ORANGE, YELLOW, GREEN, CYAN" */
	 			if (i == 0 || i == 1) {	
	 				brick.setColor(Color.RED);
	 			} else if (i == 2 || i == 3) {
	 				brick.setColor(Color.ORANGE);
	 			} else if (i == 4 || i == 5) {
	 				brick.setColor(Color.YELLOW);
	 			} else if (i == 6 || i == 7) {
	 				brick.setColor(Color.GREEN);
	 			} else if (i == 8 || i == 9) {
	 				brick.setColor(Color.CYAN);
	 			}
	 			brick.setFilled(true); 
				add(brick);
				xColumnOne += (BRICK_WIDTH + BRICK_SEP);
			}
			xColumnOne = (WIDTH - ((NBRICKS_PER_ROW - 1) * BRICK_SEP + (NBRICKS_PER_ROW * BRICK_WIDTH)));
			yRow += (BRICK_HEIGHT + BRICK_SEP);
		}
	}
	/* Creates paddle and sets starting location to center of canvas. */
	private void createPaddle() {
		paddle = new GRect ((WIDTH - PADDLE_WIDTH)/2, HEIGHT - PADDLE_Y_OFFSET, PADDLE_WIDTH, PADDLE_HEIGHT);
		paddle.setFilled(true);
		add(paddle);
	}
	/* Sets paddle to move with mouse cursor, stopping before it exits the canvas. */
	public void mouseMoved(MouseEvent e) {
		double paddleX = e.getX();
		double paddleY = HEIGHT - PADDLE_Y_OFFSET;
		paddle.setLocation(paddleX, paddleY);
		if ((paddleX + PADDLE_WIDTH) > WIDTH) {
			paddle.setLocation((WIDTH - PADDLE_WIDTH), paddleY);
		}
	}
	
	private void play() {
		createBall();
		waitForClick();
		/* Y-velocity of ball */
		vy = 5.0;
		/* X-velocity of ball */
		vx = rgen.nextDouble(1.0, 5.0); 
		if (rgen.nextBoolean(0.5)) vx = -vx;
		int bricksRemaining = (NBRICK_ROWS * NBRICKS_PER_ROW);
		youWin = new GLabel("You Win!");
		youWin.setLocation((WIDTH - youWin.getWidth()) / 2, HEIGHT / 2);
		youLose = new GLabel("You Lose :(");
		youLose.setLocation((WIDTH - youLose.getWidth()) / 2, HEIGHT / 2);
		while (true) {
			moveBall();
			checkForWallCollision();
			GObject collider = getCollidingObject();
			/*Increases velocity in both directions by 0.15 each time the ball collides with the paddle. */
			if (collider != null && collider == paddle) {
				vy = vy + 0.15;
				vx = vx + 0.15;
				/* If the ball hits the first fifth of the paddle while traveling in a positive x-direction, 
				 * or the last fifth of the paddle while traveling in a negative x-direction, x-velocity is doubled. 
				 * If the inverse of either of these is true, the ball will bounce in the opposite x-direction as it was received,
				 * and x-velocity is halved.
				 */
				if (vx > 0 && ball.getX() < (paddle.getX() + (PADDLE_WIDTH * 0.2))) {
					vx = 0.5 * vx;
					vx = -vx;
					vy = -vy;
				} else if (vx < 0 && ball.getX() < (paddle.getX() + (PADDLE_WIDTH * 0.2))) {
					vx = 2 * vx;
					vy = -vy;
				} else if (vx < 0 && ball.getX() > (paddle.getX() + (PADDLE_WIDTH * 0.8))) {
					vx = 0.5 * vx;
					vx = -vx;
					vy = -vy; 					
				} else if (vx > 0 && ball.getX() > (paddle.getX() + (PADDLE_WIDTH * 0.8))) {
					vx = 2 * vx;
					vy = -vy;
				} else vy = -vy;
			}
			if (collider != null && collider != paddle) {
				remove(collider);
				vy = -vy;
				bricksRemaining --;
			}
			if (ball.getY() + 2 * BALL_RADIUS > HEIGHT) {
				add(youLose);
				remove(ball);
				break;
			}
			if (bricksRemaining == 0) {
				add(youWin);
				remove(ball);
				break;
			}
			pause(DELAY);
		}
		waitForClick();
		remove(youLose);
		remove(youWin);
	}
	
	private void createBall(){
		ball = new GOval ((WIDTH - (2 * BALL_RADIUS)) / 2, (HEIGHT - (2 * BALL_RADIUS)) / 2, 2 * BALL_RADIUS, 2 * BALL_RADIUS);
		ball.setFilled(true);
		add(ball);
	}
	
	private void moveBall() {
		ball.move(vx,vy);
	}
	
	private void checkForWallCollision() {
		if (ball.getX() + 2 * BALL_RADIUS > WIDTH || ball.getX() < 0) {
			vx = -vx;
		}
		if (ball.getY() < 0) {
			vy = -vy;
		}
	}
	
	/* Checks for ball collisions with objects other than the walls, using the four points of the surrounding rectangle as "check" points. */
	private GObject getCollidingObject() {
		if (getElementAt(ball.getX(), ball.getY()) != null) {
			collidingObject = getElementAt(ball.getX(), ball.getY());
		} else if (getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY()) != null) {
			collidingObject = getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY());
		} else if (getElementAt(ball.getX(), ball.getY() + (2 * BALL_RADIUS)) != null) {
			collidingObject = getElementAt(ball.getX(), ball.getY() + (2 * BALL_RADIUS));
		} else if (getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY() + (2 * BALL_RADIUS)) != null) {
			collidingObject = getElementAt(ball.getX() + (2 * BALL_RADIUS), ball.getY() + (2 * BALL_RADIUS));
		} else {
			collidingObject = null;
		}
		
		return collidingObject;

	}
	
	private GLabel youWin;
	
	private GLabel youLose;
	
	private int numberOfTurns;
	
	private GObject collidingObject;
	
	private GRect paddle;
	
	private GOval ball;
	
	private double vx, vy;
	
	private RandomGenerator rgen = RandomGenerator.getInstance();

}
